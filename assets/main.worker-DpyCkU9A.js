function V(c,s){if(c.type==="tail"||s.type==="tail")return[];const e=c,n=s,r=e.p*n.p;if(e.type==="atom"&&n.type==="atom")return[{type:"atom",x:e.x+n.x,p:r}];if(e.type==="atom"&&n.type==="bin")return L(n,e.x,r);if(e.type==="bin"&&n.type==="atom")return L(e,n.x,r);if(e.type==="bin"&&n.type==="bin"){const i=e.b-e.a,a=n.b-n.a,o=i*i/12,l=a*a/12,p=o+l,h=Math.sqrt(12*p),u=(e.a+e.b)/2,m=(n.a+n.b)/2,g=u+m;return[{type:"bin",a:g-h/2,b:g+h/2,p:r,repr:g,shape:"uniform"}]}return[]}function L(c,s,t){return[{type:"bin",a:c.a+s,b:c.b+s,p:t,repr:c.repr+s,shape:c.shape}]}let k=null,A=null,I=null,v=null,N=null,P=null,D=null;function _(c){k=c}function $(c){A=c.mean,I=c.variance,v=c.std,N=c.probGt,P=c.mix,D=c.scale}function x(c){const s=[];for(const t of c)if(t.type==="atom")s.push(0,t.x,t.p);else if(t.type==="bin")s.push(1,t.a,t.b,t.p);else if(t.type==="tail"){const e=t.params.lambda||1,n=t.side==="right"?1:0;s.push(2,t.x0,t.mass,e,n)}return new Float64Array(s)}function C(c){const s=[];let t=0;for(;t<c.length;){const e=c[t];e===0&&t+2<c.length?(s.push({type:"atom",x:c[t+1],p:c[t+2]}),t+=3):e===1&&t+3<c.length?(s.push({type:"bin",a:c[t+1],b:c[t+2],p:c[t+3],repr:(c[t+1]+c[t+2])/2,shape:"uniform"}),t+=4):e===2&&t+4<c.length?(s.push({type:"tail",x0:c[t+1],mass:c[t+2],side:c[t+4]>.5?"right":"left",family:"exp",params:{lambda:c[t+3]}}),t+=5):t++}return s}class f{components=[];constructor(s=[]){this.components=[...s],this.sort()}sort(){this.components.sort((s,t)=>{const e=n=>n.type==="atom"?n.x:n.type==="bin"?n.a:n.type==="tail"?n.side==="left"?Number.NEGATIVE_INFINITY:n.x0:0;return e(s)-e(t)})}normalize(){let s=0;for(const e of this.components)e.type==="tail"?s+=e.mass:s+=e.p;if(s===0||Math.abs(s-1)<1e-9)return;const t=1/s;for(const e of this.components)e.type==="tail"?e.mass*=t:e.p*=t}add(s){if(k&&this.components.length>0&&s.components.length>0){const e=x(this.components),n=x(s.components),r=k(e,n);return new f(C(r))}const t=[];for(const e of this.components)for(const n of s.components)t.push(...V(e,n));return new f(t)}sub(s){return this.add(s.scale(-1))}scale(s){if(D&&this.components.length>0){const e=x(this.components),n=D(e,s);return new f(C(n))}const t=this.components.map(e=>{if(e.type==="atom")return{...e,x:e.x*s};if(e.type==="bin"){const n=e.a*s,r=e.b*s;return{...e,a:Math.min(n,r),b:Math.max(n,r),repr:e.repr*s}}else if(e.type==="tail")return e;return e});return new f(t)}reciprocal(){const s=[];for(const t of this.components)if(t.type==="atom"){if(t.x===0)continue;s.push({...t,x:1/t.x})}else if(t.type==="bin")if(t.a<=0&&t.b>=0){if(t.a<0&&t.b>0){const e=t.b-t.a,n=t.p*(-t.a/e),r=t.p*(t.b/e);if(t.a<0){const i=(t.a+Math.min(0,t.a/2))/2;s.push({type:"atom",x:1/i,p:n})}if(t.b>0){const i=(Math.max(0,t.b/2)+t.b)/2;s.push({type:"atom",x:1/i,p:r})}}else if(t.a===0){const e=t.b/2;s.push({type:"atom",x:1/e,p:t.p})}else if(t.b===0){const e=t.a/2;s.push({type:"atom",x:1/e,p:t.p})}}else{const e=1/t.b,n=1/t.a;s.push({...t,a:Math.min(e,n),b:Math.max(e,n),repr:1/t.repr})}else if(t.type==="tail"){const e=t.params.lambda||1,n=t.side==="right"?t.x0+1/e:t.x0-1/e;n!==0&&s.push({type:"atom",x:1/n,p:t.mass})}return new f(s)}mix(s,t){if(P&&this.components.length>0&&s.components.length>0){const i=x(this.components),a=x(s.components),o=P(i,a,t);return new f(C(o))}const e=(i,a)=>i.type==="tail"?{...i,mass:i.mass*a}:{...i,p:i.p*a},n=this.components.map(i=>e(i,1-t)),r=s.components.map(i=>e(i,t));return new f([...n,...r])}mean(){if(A&&this.components.length>0){const t=x(this.components);return A(t)}let s=0;for(const t of this.components)if(t.type==="atom")s+=t.p*t.x;else if(t.type==="bin")s+=t.p*(t.a+t.b)/2;else if(t.type==="tail"){const e=t.params.lambda||1,n=t.side==="right"?t.x0+1/e:t.x0-1/e;s+=t.mass*n}return s}variance(){if(I&&this.components.length>0){const e=x(this.components);return I(e)}const s=this.mean();let t=0;for(const e of this.components)if(e.type==="atom")t+=e.p*e.x*e.x;else if(e.type==="bin")t+=e.p*(e.a*e.a+e.a*e.b+e.b*e.b)/3;else if(e.type==="tail"){const n=e.params.lambda||1,r=e.side==="right"?e.x0+1/n:e.x0-1/n,i=1/(n*n);t+=e.mass*(i+r*r)}return t-s*s}std(){if(v&&this.components.length>0){const s=x(this.components);return v(s)}return Math.sqrt(this.variance())}median(){let s=0;const t=.5;for(const e of this.components){const n=e.type==="tail"?e.mass:e.p;if(s+n>=t){const r=t-s;if(e.type==="atom")return e.x;if(e.type==="bin"){const i=r/n;return e.a+i*(e.b-e.a)}else if(e.type==="tail"){const i=e.params.lambda||1;if(e.side==="left"){const a=r/n;return e.x0+Math.log(a)/i}else{const a=r/n;return e.x0-Math.log(1-a)/i}}}s+=n}return 0}probGt(s){if(N&&this.components.length>0){const e=x(this.components);return N(e,s)}let t=0;for(const e of this.components)if(e.type==="atom")e.x>s&&(t+=e.p);else if(e.type==="bin"){if(e.a>=s)t+=e.p;else if(e.b>s){const n=e.b-e.a,r=e.b-s;t+=e.p*(r/n)}}else if(e.type==="tail"){if(e.side==="right")if(s<e.x0)t+=e.mass;else{const n=e.params.lambda||1;t+=e.mass*Math.exp(-n*(s-e.x0))}else if(s<e.x0){const n=e.params.lambda||1;t+=e.mass*(1-Math.exp(-n*(e.x0-s)))}}return t}sample(s){const t=this.components.length;if(t===0)return[];const e=this.components.map(h=>h.type==="tail"?h.mass:h.p),n=e.reduce((h,u)=>h+u,0);if(n===0)return[];const r=e.map(h=>h/n*t),i=new Array(t).fill(0),a=new Array(t).fill(0),o=[],l=[];for(let h=0;h<t;h++)r[h]<1?o.push(h):l.push(h);for(;o.length>0&&l.length>0;){const h=o.pop(),u=l.pop();a[h]=r[h],i[h]=u,r[u]=r[u]+r[h]-1,r[u]<1?o.push(u):l.push(u)}for(;l.length>0;)a[l.pop()]=1;for(;o.length>0;)a[o.pop()]=1;const p=[];for(let h=0;h<s;h++){const u=Math.random()*t,m=Math.floor(u),b=u-m<a[m]?m:i[m],w=this.components[b];if(w.type==="atom")p.push(w.x);else if(w.type==="bin")p.push(w.a+Math.random()*(w.b-w.a));else if(w.type==="tail"){const d=w.params.lambda||1,y=-Math.log(1-Math.random())/d;w.side==="right"?p.push(w.x0+y):p.push(w.x0-y)}}return p}maxOf(s,t=200){if(this.components.length===0)return new f([]);if(s===1)return this;let e=1/0,n=-1/0;for(const o of this.components)o.type==="atom"?(e=Math.min(e,o.x),n=Math.max(n,o.x)):o.type==="bin"&&(e=Math.min(e,o.a),n=Math.max(n,o.b)),o.type==="tail"&&(o.side==="right"&&(e=Math.min(e,o.x0)),o.side==="left"&&(n=Math.max(n,o.x0)));if(e>=n)return this;const r=(n-e)/t,i=[];for(let o=0;o<=t;o++){const l=e+o*r,p=1-this.probGt(l),h=Math.pow(p,s),u=h-(o===0?0:Math.pow(1-this.probGt(l-r),s));u>1e-9&&(o>0?i.push({type:"bin",a:l-r,b:l,p:u,repr:l-r/2,shape:"uniform"}):h>1e-9&&i.push({type:"atom",x:l,p:h}))}const a=new f(i);return a.normalize(),a}splitAt(s){const t=[],e=[];for(const n of this.components)if(n.type==="atom")n.x<=s?t.push(n):e.push(n);else if(n.type==="bin")if(n.b<=s)t.push(n);else if(n.a>=s)e.push(n);else{const r=n.b-n.a,i=s-n.a,a=n.b-s,o=n.p*(i/r),l=n.p*(a/r);t.push({...n,b:s,p:o,repr:(n.a+s)/2}),e.push({...n,a:s,p:l,repr:(s+n.b)/2})}else if(n.type==="tail")if(n.side==="right")if(s<=n.x0)e.push(n);else if(s>n.x0){const r=n.params.lambda||1,i=n.mass*Math.exp(-r*(s-n.x0)),a=n.mass-i;t.push({type:"atom",x:(n.x0+s)/2,p:a}),e.push({...n,x0:s,mass:i})}else e.push(n);else if(s>=n.x0)t.push(n);else{const r=n.params.lambda||1,i=n.mass*Math.exp(-r*(n.x0-s)),a=n.mass-i;t.push({...n,x0:s,mass:i}),e.push({type:"atom",x:(s+n.x0)/2,p:a})}return[new f(t),new f(e)]}toString(){return this.components.map(s=>s.type==="atom"?`Atom(${s.x.toFixed(2)}, p=${s.p.toFixed(3)})`:s.type==="bin"?`Bin([${s.a.toFixed(2)},${s.b.toFixed(2)}], p=${s.p.toFixed(3)})`:s.type==="tail"?`Tail(${s.side}, x0=${s.x0}, m=${s.mass.toFixed(3)})`:"Unknown").join(`
`)}}class G{id;rawInput="";value;status="ok";error=null;dependencies=new Set;dependents=new Set;constructor(s){this.id=s,this.value=new f([])}}function U(c,s){c.normalize();let t=[...c.components];const e=s.boundaries||[];e.length>0&&(t=T(t,e));const n=s.impactCenter??0,r=s.impactWidthWeight??0,i=a=>{let o=0,l=0,p=0;if(a.type==="atom")o=a.x,p=a.p;else if(a.type==="bin")o=a.repr,l=a.b-a.a,p=a.p;else if(a.type==="tail")return Number.MAX_VALUE;const h=Math.abs(o-n)+r*l;return p*h};return s.tau!==void 0&&(t=z(t,s.tau,e,i)),t.length>Math.max(1e3,s.targetN*4)&&(t=W(t,s.targetN*2,e)),t.length>s.targetN&&(t=X(t,s.targetN,e,i)),new f(t)}function W(c,s,t){let e=1/0,n=-1/0;for(const o of c){const l=E(o),p=M(o);l<e&&(e=l),p>n&&(n=p)}if(e>=n)return c;const r=(n-e)/s,i=Array.from({length:s},()=>[]);for(const o of c){const l=(E(o)+M(o))/2;let p=Math.floor((l-e)/r);p<0&&(p=0),p>=s&&(p=s-1),i[p].push(o)}const a=[];for(const o of i)o.length>0&&a.push(O(o));return t.length>0?T(a,t):a}function T(c,s){let t=c;for(const e of s){const n=[];for(const r of t)if(r.type==="bin"&&r.a<e&&r.b>e){const i=r.b-r.a,a=e-r.a,o=r.b-e,l=r.p*(a/i),p=r.p*(o/i);n.push({type:"bin",a:r.a,b:e,p:l,repr:(r.a+e)/2,shape:r.shape}),n.push({type:"bin",a:e,b:r.b,p,repr:(e+r.b)/2,shape:r.shape})}else n.push(r);t=n}return t}function z(c,s,t,e){const n=[];let r=[];const i=()=>{r.length!==0&&(r.length===1?n.push(r[0]):n.push(O(r)),r=[])};for(const a of c)if(e(a)<s){if(r.length>0){const o=r[r.length-1];q(M(o),E(a),t)&&i()}r.push(a)}else i(),n.push(a);return i(),n}function X(c,s,t,e){const n=[...c];for(;n.length>s;){let r=-1,i=Number.MAX_VALUE;for(let o=0;o<n.length-1;o++){const l=n[o],p=n[o+1];if(q(M(l),E(p),t)||l.type==="tail"||p.type==="tail")continue;const h=e(l)+e(p);h<i&&(i=h,r=o)}if(r===-1)break;const a=O([n[r],n[r+1]]);n.splice(r,2,a)}return n}function E(c){return c.type==="atom"?c.x:c.type==="bin"?c.a:c.type==="tail"?c.side==="left"?-1/0:c.x0:0}function M(c){return c.type==="atom"?c.x:c.type==="bin"?c.b:c.type==="tail"?c.side==="left"?c.x0:1/0:0}function q(c,s,t){return t.some(e=>e>=c&&e<=s)}function O(c){let s=1/0,t=-1/0,e=0,n=0;for(const i of c){const a=i.type==="tail"?i.mass:i.p;e+=a;let o=0,l=0,p=0;i.type==="atom"?(o=i.x,l=i.x,p=i.x):i.type==="bin"&&(o=i.a,l=i.b,p=i.repr),s=Math.min(s,o),t=Math.max(t,l),n+=p*a}const r=e>0?n/e:(s+t)/2;return{type:"bin",a:s,b:t,p:e,repr:r,shape:"uniform"}}function J(c){const s=[];let t=0;for(;t<c.length;){const e=c[t];if(/\s/.test(e)){t++;continue}if(/[0-9.]/.test(e)){let n="";for(;t<c.length&&/[0-9.]/.test(c[t]);)n+=c[t],t++;s.push({type:"NUMBER",value:n});continue}if(/[A-Za-z_]/.test(e)){let n="";for(;t<c.length&&/[A-Za-z0-9_]/.test(c[t]);)n+=c[t],t++;s.push({type:"ID",value:n});continue}switch(e){case"+":s.push({type:"PLUS",value:"+"});break;case"-":s.push({type:"MINUS",value:"-"});break;case"*":s.push({type:"MUL",value:"*"});break;case"/":s.push({type:"DIV",value:"/"});break;case"(":s.push({type:"LPAREN",value:"("});break;case")":s.push({type:"RPAREN",value:")"});break;case",":s.push({type:"COMMA",value:","});break;case":":s.push({type:"COLON",value:":"});break;default:throw new Error(`Unknown character: ${e}`)}t++}return s}function Z(c,s){const t=w=>{const d=w.toUpperCase().match(/^([A-Z]+)([0-9]+)$/);if(!d)throw new Error(`Invalid cell ref in range: ${w}`);return{col:d[1],row:parseInt(d[2],10)}},e=t(c),n=t(s),r=w=>{let d=0;for(let y=0;y<w.length;y++)d*=26,d+=w.charCodeAt(y)-65+1;return d-1},i=w=>{let d="",y=w;for(;y>=0;)d=String.fromCharCode(65+y%26)+d,y=Math.floor(y/26)-1;return d},a=r(e.col),o=r(n.col),l=e.row,p=n.row,h=Math.min(a,o),u=Math.max(a,o),m=Math.min(l,p),g=Math.max(l,p),b=[];for(let w=m;w<=g;w++)for(let d=h;d<=u;d++)b.push(`${i(d)}${w}`);return b}class j{tokens;pos=0;ctx;localMaxComponents;constructor(s,t){this.tokens=s,this.ctx=t}peek(){return this.tokens[this.pos]}consume(){return this.tokens[this.pos++]}expect(s){const t=this.consume();if(!t||t.type!==s)throw new Error(`Expected ${s}, got ${t?.type}`);return t}checkSafety(s){const t=this.localMaxComponents??this.ctx.maxComponents??200;return s.components.length>t?U(s,{targetN:t}):s}parseExpression(){let s=this.parseTerm();for(;this.pos<this.tokens.length;){const t=this.peek();if(t?.type==="PLUS"){this.consume();const e=this.parseTerm();s=s.add(e),s=this.checkSafety(s)}else if(t?.type==="MINUS"){this.consume();const e=this.parseTerm();s=s.sub(e),s=this.checkSafety(s)}else break}return s}parseTerm(){let s=this.parseFactor();for(;this.pos<this.tokens.length;){const t=this.peek();if(t?.type==="MUL"){this.consume();const e=this.parseFactor();if(this.isScalar(e))s=s.scale(this.getScalar(e));else if(this.isScalar(s)){const n=this.getScalar(s);s=e.scale(n)}else throw new Error("Multiplication of two Distributions not supported (Scalar required)");s=this.checkSafety(s)}else if(t?.type==="DIV"){this.consume();const e=this.parseFactor();if(this.isScalar(e)){const n=this.getScalar(e);if(n===0)throw new Error("Division by Zero");s=s.scale(1/n)}else if(this.isScalar(s)){const n=this.getScalar(s);s=e.reciprocal().scale(n)}else throw new Error("Division of two Distributions not supported");s=this.checkSafety(s)}else break}return s}parseFactor(){const s=this.peek();if(!s)throw new Error("Unexpected end of input");if(s.type==="NUMBER"){this.consume();const t=parseFloat(s.value);return new f([{type:"atom",x:t,p:1}])}if(s.type==="ID"){const t=s.value;return this.consume(),this.peek()?.type==="LPAREN"?this.parseFunctionCall(t):this.ctx.getValue(t)}if(s.type==="MINUS")return this.consume(),this.parseFactor().scale(-1);if(s.type==="LPAREN"){this.consume();const t=this.parseExpression();return this.expect("RPAREN"),t}throw new Error(`Unexpected token: ${s.type}`)}parseFunctionCall(s){this.expect("LPAREN");const t=[];if(this.peek()?.type!=="RPAREN"){if(s.toUpperCase()==="CONFIG"){const r=this.parseExpression(),i=this.getScalar(r);this.expect("COMMA");const a=this.localMaxComponents;this.localMaxComponents=i;const o=this.parseExpression();return this.localMaxComponents=a,this.expect("RPAREN"),o}const n=()=>{if(this.peek()?.type==="ID"&&this.tokens[this.pos+1]?.type==="COLON"){const r=this.consume().value;this.consume();const i=this.expect("ID").value;Z(r,i).forEach(o=>{t.push(this.ctx.getValue(o))});return}t.push(this.parseExpression())};for(n();this.peek()?.type==="COMMA";)this.consume(),n()}this.expect("RPAREN");const e=s.toUpperCase();if(e==="CONST"){if(t.length!==1)throw new Error("CONST requires 1 arg (x)");const n=this.getScalar(t[0]);return new f([{type:"atom",x:n,p:1}])}else if(e==="UNIFORM"){if(t.length!==2)throw new Error("UNIFORM requires 2 args (min, max)");const n=this.getScalar(t[0]),r=this.getScalar(t[1]);if(n>=r)throw new Error("UNIFORM min must be < max");return new f([{type:"bin",a:n,b:r,p:1,repr:(n+r)/2,shape:"uniform"}])}else if(e==="NORMAL"){if(t.length!==2)throw new Error("NORMAL requires 2 args (mean, std)");const n=this.getScalar(t[0]),r=this.getScalar(t[1]);if(r<=0)throw new Error("NORMAL std must be > 0");const i=[],a=20,o=n-4*r,p=(n+4*r-o)/a,h=g=>1/(r*Math.sqrt(2*Math.PI))*Math.exp(-.5*Math.pow((g-n)/r,2));let u=0;for(let g=0;g<a;g++){const b=o+g*p,w=b+p,d=(b+w)/2,y=h(d)*p;u+=y,i.push({type:"bin",a:b,b:w,p:y,repr:d,shape:"uniform"})}const m=1/u;return i.forEach(g=>g.type==="bin"?g.p*=m:null),new f(i)}else if(e==="DISCRETE"){if(t.length===0||t.length%2!==0)throw new Error("DISCRETE requires pairs of args (value, prob, ...)");const n=[];let r=0;for(let i=0;i<t.length;i+=2){const a=this.getScalar(t[i]),o=this.getScalar(t[i+1]);if(o<0)throw new Error("Probability must be >= 0");n.push({type:"atom",x:a,p:o}),r+=o}if(r===0)throw new Error("Total probability cannot be zero");return new f(n)}else if(e==="EXPONENTIAL"){if(t.length!==1)throw new Error("EXPONENTIAL requires 1 arg (rate)");const n=this.isScalar(t[0])?this.getScalar(t[0]):t[0].mean();if(n<=0)throw new Error("Rate must be > 0");const r=7/n,i=50,a=r/i,o=[];for(let p=0;p<i;p++){const h=p*a,u=(p+1)*a,m=Math.exp(-n*h)-Math.exp(-n*u);o.push({type:"bin",a:h,b:u,p:m,repr:(h+u)/2,shape:"uniform"})}const l=o.reduce((p,h)=>p+(h.type==="tail"?h.mass:h.p),0);return o.forEach(p=>{p.type==="bin"&&(p.p/=l)}),new f(o)}else if(e==="POISSON"){if(t.length!==1)throw new Error("POISSON requires 1 arg (lambda)");const n=this.getScalar(t[0]);if(n<=0)throw new Error("Lambda must be > 0");const r=this.localMaxComponents??200,i=[];let a=Math.exp(-n),o=0;for(let l=0;l<r&&(i.push({type:"atom",x:l,p:a}),o+=a,a=a*n/(l+1),!(o>.99999));l++);return i.forEach(l=>{l.type==="atom"&&(l.p/=o)}),new f(i)}else if(e==="BINOMIAL"){if(t.length!==2)throw new Error("BINOMIAL requires 2 args (n, p)");const n=Math.floor(this.getScalar(t[0])),r=this.getScalar(t[1]);if(n<0)throw new Error("n must be >= 0");if(r<0||r>1)throw new Error("p must be between 0 and 1");const i=this.localMaxComponents??200;if(n>i)throw new Error(`BINOMIAL n=${n} exceeds component limit ${i}.`);const a=[];let o=Math.pow(1-r,n),l=0;for(let p=0;p<=n&&(a.push({type:"atom",x:p,p:o}),l+=o,p!==n);p++)o=o*((n-p)/(p+1))*(r/(1-r));return l>0&&a.forEach(p=>{p.type==="atom"&&(p.p/=l)}),new f(a)}else if(e==="ADD"){if(t.length!==2)throw new Error("ADD requires 2 args (A, B)");return this.checkSafety(t[0].add(t[1]))}else if(e==="CONVOLVE"){if(t.length!==2)throw new Error("CONVOLVE requires 2 args (d1, d2)");return this.checkSafety(t[0].add(t[1]))}else if(e==="MUL"){if(t.length!==2)throw new Error("MUL requires 2 args (A, B)");if(this.isScalar(t[0]))return this.checkSafety(t[1].scale(this.getScalar(t[0])));if(this.isScalar(t[1]))return this.checkSafety(t[0].scale(this.getScalar(t[1])));throw new Error("MUL currently supports only Scalar * Dist or Dist * Scalar")}else if(e==="DIV"){if(t.length!==2)throw new Error("DIV requires 2 args (A, B)");if(this.isScalar(t[1])){const n=this.getScalar(t[1]);if(n===0)throw new Error("Division by Zero");return this.checkSafety(t[0].scale(1/n))}else if(this.isScalar(t[0])){const n=this.getScalar(t[0]);return this.checkSafety(t[1].reciprocal().scale(n))}else throw new Error("DIV of two Distributions not supported")}else if(e==="POWER"){if(t.length!==2)throw new Error("POWER requires 2 args (Dist, exponent)");const n=t[0],r=this.getScalar(t[1]),i=n.components.map(o=>o.type==="atom"?{...o,x:Math.pow(o.x,r)}:o.type==="bin"?{...o,a:Math.pow(o.a,r),b:Math.pow(o.b,r),repr:Math.pow(o.repr,r)}:o);i.forEach(o=>{if(o.type==="bin"&&o.a>o.b){const l=o.a;o.a=o.b,o.b=l}});const a=new f(i);return this.checkSafety(a)}else if(e==="BIN"){if(t.length<2)throw new Error("BIN requires at least 2 args (a, b, [p])");const n=this.getScalar(t[0]),r=this.getScalar(t[1]),i=t.length>2?this.getScalar(t[2]):1;return new f([{type:"bin",a:n,b:r,p:i,repr:(n+r)/2,shape:"uniform"}])}if(e==="SCALE"){if(t.length!==2)throw new Error("SCALE requires 2 args (A, k)");const n=this.getScalar(t[1]);return this.checkSafety(t[0].scale(n))}if(e==="MIX"){if(t.length!==3)throw new Error("MIX requires 3 args (A, B, p)");let n;if(this.isScalar(t[0])){const r=this.getScalar(t[0]);n=t[2].mix(t[1],r)}else{const r=this.getScalar(t[0]);n=t[2].mix(t[1],r)}return this.checkSafety(n)}if(e==="REDUCE"){if(t.length<2)throw new Error("REDUCE requires at least 2 args (A, targetN)");const n=t[0],r=this.getScalar(t[1]),i=t.length>2?this.getScalar(t[2]):0,a=t.length>3?this.getScalar(t[3]):.01,o=[0],l=t.length>5?this.getScalar(t[5]):0;return U(n,{targetN:r,impactCenter:i,tau:a,boundaries:o,impactWidthWeight:l})}if(e==="GEOM_SUM"){if(t.length!==2)throw new Error("GEOM_SUM requires 2 args (Dist, p)");const n=t[0],r=this.getScalar(t[1]);if(r<0||r>=1)throw new Error("p must be in [0, 1)");if(r===0)return new f([{type:"atom",x:0,p:1}]);let i=[],a=new f([{type:"atom",x:0,p:1}]),o=1-r,l=0,p=0;const h=2e3;for(;p<h;){for(const m of a.components)m.type==="atom"?i.push({...m,p:m.p*o}):m.type==="bin"?i.push({...m,p:m.p*o}):m.type==="tail"&&i.push({...m,mass:m.mass*o});if(l+=o,l>.9999)break;o*=r/(1-r),a=a.add(n),a=this.checkSafety(a),o=(1-r)*Math.pow(r,p+1),o=(1-r)*Math.pow(r,p+1),p++}const u=new f(i);return this.checkSafety(u)}if(e==="REPEAT_ADD"){if(t.length!==2)throw new Error("REPEAT_ADD requires 2 args (Dist, N)");const n=t[0],r=Math.floor(this.getScalar(t[1]));if(r<=0)return new f([{type:"atom",x:0,p:1}]);if(r===1)return n;let i=new f([{type:"atom",x:0,p:1}]),a=n,o=r;for(;o>0;)o%2===1&&(i=i.add(a),i=this.checkSafety(i)),a=a.add(a),a=this.checkSafety(a),o=Math.floor(o/2);return i}if(e==="MEAN"){if(t.length!==1)throw new Error("MEAN requires 1 arg (A)");const n=t[0].mean();return new f([{type:"atom",x:n,p:1}])}if(e==="PROB_GT"){if(t.length!==2)throw new Error("PROB_GT requires 2 args (A, x)");const n=this.getScalar(t[1]),r=t[0].probGt(n);return new f([{type:"atom",x:r,p:1}])}if(e==="RESAMPLE"){if(t.length!==2)throw new Error("RESAMPLE requires 2 args (A, n)");const n=this.getScalar(t[1]),i=t[0].sample(n).map(o=>({type:"atom",x:o,p:1})),a=new f(i);return a.normalize(),this.checkSafety(a)}if(e==="REF"){if(t.length!==1)throw new Error("REF requires 1 arg");return t[0]}if(e==="SUB"){if(t.length!==2)throw new Error("SUB requires 2 args (A, B)");return this.checkSafety(t[0].sub(t[1]))}if(e==="VAR"){if(t.length!==1)throw new Error("VAR requires 1 arg (Dist)");const n=t[0].variance();return new f([{type:"atom",x:n,p:1}])}if(e==="STD"){if(t.length!==1)throw new Error("STD requires 1 arg (Dist)");const n=t[0].std();return new f([{type:"atom",x:n,p:1}])}if(e==="MEDIAN"){if(t.length!==1)throw new Error("MEDIAN requires 1 arg (Dist)");const n=t[0].median();return new f([{type:"atom",x:n,p:1}])}if(e==="SHIFT"){if(t.length!==2)throw new Error("SHIFT requires 2 args (Dist, k)");const n=t[0],r=this.getScalar(t[1]),i=new f([{type:"atom",x:r,p:1}]);return this.checkSafety(n.add(i))}if(e==="CHOICE"){if(t.length<2||t.length%2!==0)throw new Error("CHOICE requires even args (v1, p1, v2, p2, ...)");const n=[];for(let i=0;i<t.length;i+=2){const a=this.getScalar(t[i]),o=this.getScalar(t[i+1]);n.push({type:"atom",x:a,p:o})}const r=new f(n);return r.normalize(),this.checkSafety(r)}if(e==="MAX_OF"){if(t.length!==2)throw new Error("MAX_OF requires 2 args (Dist, N)");const n=t[0],r=this.getScalar(t[1]);return this.checkSafety(n.maxOf(r))}if(e==="RUIN_PROB"){if(t.length!==3)throw new Error("RUIN_PROB requires 3 args (StepDist, InitWealth, Steps)");const n=t[0],r=this.getScalar(t[1]),i=Math.floor(this.getScalar(t[2]));if(i>300){const h=Math.max(1e3,Math.min(1e4,Math.floor(1e7/i)));let u=0;if(this.ctx.wasmMonteCarlo)u=this.ctx.wasmMonteCarlo(n.components,r,i,h);else for(let g=0;g<h;g++){let b=r;const w=n.sample(i);for(const d of w)if(b+=d,b<=0){u++;break}}const m=u/h;return new f([{type:"atom",x:m,p:1}])}let a=new f([{type:"atom",x:r,p:1}]),o=0,l=1;for(let p=0;p<i;p++){a=a.add(n),a=this.checkSafety(a);const[h,u]=a.splitAt(0);let m=0;for(const g of h.components)m+=g.type==="tail"?g.mass:g.p;if(o+=l*m,l*=1-m,l<1e-9){o=1;break}a=u,a.normalize()}return new f([{type:"atom",x:o,p:1}])}throw new Error(`Unknown function: ${s}`)}isScalar(s){return s.components.length===1&&s.components[0].type==="atom"&&Math.abs(s.components[0].p-1)<1e-9}getScalar(s){if(this.isScalar(s)){if(s.components.length===0)return 0;if(s.components[0].type==="atom")return s.components[0].x}throw new Error("Expected scalar value (single atom with p=1)")}}function H(c,s){try{if(!c)return new f([]);const t=J(c);return new j(t,s).parseExpression()}catch(t){throw new Error(`Eval Error: ${t.message}`)}}class Y{cells=new Map;listeners=[];dirtyTrack=new Set;wasmMonteCarlo=null;subscribe(s){return this.listeners.push(s),()=>{this.listeners=this.listeners.filter(t=>t!==s)}}notifyListeners(){this.listeners.forEach(s=>s())}getDirtyAndClear(){const s=[];for(const t of this.dirtyTrack){const e=this.cells.get(t);e&&s.push(e)}return this.dirtyTrack.clear(),s}markDirty(s){this.dirtyTrack.add(s)}getCell(s){return this.cells.has(s)||this.cells.set(s,new G(s)),this.cells.get(s)}getAllCells(){return this.cells.values()}setCellInput(s,t){const e=this.getCell(s);if(e.rawInput===t)return;e.rawInput=t,this.markDirty(s);const n=this.detectDependencies(t);this.updateDependencies(e,n),this.recalculate(s)}detectDependencies(s){const t=new Set,e=/\b([A-Z]+[0-9]+)\b/g;let n;for(;(n=e.exec(s))!==null;)t.add(n[1]);return t}updateDependencies(s,t){for(const e of s.dependencies)t.has(e)||this.getCell(e).dependents.delete(s.id);for(const e of t)s.dependencies.has(e)||this.getCell(e).dependents.add(s.id);s.dependencies=t}async recalculate(s){const e=(a=>{const o=[a],l=new Set;for(;o.length>0;){const p=o.shift();if(l.has(p))continue;l.add(p);const h=this.getCell(p);h.status!=="circular"&&(h.status="evaluating",this.markDirty(h.id));for(const u of h.dependents)o.push(u)}return l})(s);this.notifyListeners();const n=new Map;for(const a of e)n.set(a,0);for(const a of e){const o=this.getCell(a);for(const l of o.dependents)e.has(l)&&n.set(l,(n.get(l)||0)+1)}const r=[];for(const[a,o]of n)o===0&&r.push(a);let i=0;for(;r.length>0;){const a=r.shift(),o=this.getCell(a);this.evaluateCell(o),i++,i%5===0&&(await new Promise(l=>setTimeout(l,0)),this.notifyListeners());for(const l of o.dependents)if(e.has(l)){const p=(n.get(l)||0)-1;n.set(l,p),p===0&&r.push(l)}}if(i<e.size){for(const[a,o]of n)if(o>0){const l=this.getCell(a);l.status="circular",this.markDirty(a)}}this.notifyListeners()}evaluateCell(s){if(s.status!=="circular")try{if(s.rawInput.startsWith("=")){const t=s.rawInput.substring(1);s.value=this.evaluateExpression(t)}else{const t=s.rawInput.trim(),e=t===""?NaN:Number(t);isNaN(e)?s.value=new f([]):s.value=new f([{type:"atom",x:e,p:1}])}s.status="ok",this.markDirty(s.id)}catch(t){s.status="error",s.error=t.message,this.markDirty(s.id)}}config={maxComponents:200};setGlobalConfig(s){this.config=s}evaluateExpression(s){return H(s,{getValue:t=>this.getCell(t).value,maxComponents:this.config.maxComponents,wasmMonteCarlo:this.wasmMonteCarlo??void 0})}toJSON(){const s={version:1,config:this.config,cells:{}};for(const[t,e]of this.cells)e.rawInput&&(s.cells[t]=e.rawInput);return JSON.stringify(s,null,2)}fromJSON(s){try{const t=JSON.parse(s);if(!t||typeof t!="object")throw new Error("Invalid BNPU file");if(t.config&&this.setGlobalConfig(t.config),this.cells.clear(),t.cells)for(const[e,n]of Object.entries(t.cells))this.setCellInput(e,n)}catch(t){throw console.error("Failed to load file",t),t}}}const R=self,S=new Y;async function K(){try{const c=await import("./wasm_bunpu-BaPKTBeH.js");await c.default();const s=(t,e,n,r)=>{const i=[];for(const a of t)if(a.type==="atom")i.push(0,a.x,a.p);else if(a.type==="bin")i.push(1,a.a,a.b,a.p);else if(a.type==="tail"){const o=a.params.lambda||1,l=a.side==="right"?1:0;i.push(2,a.x0,a.mass,o,l)}return c.run_monte_carlo(new Float64Array(i),e,n,r)};S.wasmMonteCarlo=s,_((t,e)=>c.convolve_distributions(t,e)),$({mean:t=>c.dist_mean(t),variance:t=>c.dist_variance(t),std:t=>c.dist_std(t),probGt:(t,e)=>c.dist_prob_gt(t,e),mix:(t,e,n)=>c.dist_mix(t,e,n),scale:(t,e)=>c.dist_scale(t,e)}),console.log("[Worker] Wasm fully initialized (MC + Conv + Dist ops)")}catch(c){console.warn("[Worker] Wasm not available, using JS fallback:",c)}}K();R.onmessage=async c=>{const s=c.data;s.type==="SET_INPUT"?S.setCellInput(s.type==="SET_INPUT"?s.id:"",s.val):s.type==="SET_CONFIG"?S.setGlobalConfig(s.config):s.type==="LOAD_JSON"?(S.fromJSON(s.json),F()):s.type==="GET_ALL"&&F()};S.subscribe(()=>{const c=S.getDirtyAndClear();c&&B(c)});function B(c){const t={type:"UPDATE_CELLS",updates:c.map(e=>({id:e.id,status:e.status,value:e.status==="ok"?{components:e.value.components}:void 0,error:e.error||void 0,rawInput:e.rawInput}))};R.postMessage(t)}function F(){const c=Array.from(S.getAllCells());B(c)}const Q={type:"READY"};R.postMessage(Q);
